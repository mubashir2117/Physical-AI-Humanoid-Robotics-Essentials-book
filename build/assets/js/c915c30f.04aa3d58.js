"use strict";(globalThis.webpackChunkphysical_ai_book=globalThis.webpackChunkphysical_ai_book||[]).push([[737],{963:(e,n,a)=>{a.d(n,{A:()=>o});a(6540);var r=a(4164);const t={callout:"callout_jYHE",info:"info_IOty",tip:"tip_s2nh",caution:"caution_w7Js",danger:"danger_zfsw",icon:"icon_Ghiv",content:"content_JMk4"};var i=a(4848);function o({type:e,children:n}){const a=function(e){switch(e){case"info":default:return"\u2139\ufe0f";case"tip":return"\ud83d\udca1";case"caution":return"\u26a0\ufe0f";case"danger":return"\u274c"}}(e),o=(0,r.A)("callout",t.callout,t[e]);return(0,i.jsxs)("div",{className:o,children:[(0,i.jsx)("div",{className:t.icon,children:a}),(0,i.jsx)("div",{className:t.content,children:n})]})}},4245:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"module-3-isaac/chapter-14-isaac-ros","title":"Chapter 14 - Isaac ROS","description":"Learning Objectives","source":"@site/docs/module-3-isaac/chapter-14-isaac-ros.mdx","sourceDirName":"module-3-isaac","slug":"/module-3-isaac/chapter-14-isaac-ros","permalink":"/humanoid-robotics/docs/module-3-isaac/chapter-14-isaac-ros","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedBy":"Muhammad Uzair","lastUpdatedAt":1765045729000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Chapter 14 - Isaac ROS"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 13 - Synthetic Data","permalink":"/humanoid-robotics/docs/module-3-isaac/chapter-13-synthetic-data"},"next":{"title":"Chapter 15 - Nav2","permalink":"/humanoid-robotics/docs/module-3-isaac/chapter-15-nav2"}}');var t=a(4848),i=a(8453),o=a(963);const s={sidebar_position:4,title:"Chapter 14 - Isaac ROS"},l="Chapter 14: Isaac ROS Integration",c={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Content with Code Examples",id:"content-with-code-examples",level:2},{value:"Mermaid Diagrams",id:"mermaid-diagrams",level:2},{value:"Callouts",id:"callouts",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2}];function m(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-14-isaac-ros-integration",children:"Chapter 14: Isaac ROS Integration"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(n.p,{children:"After completing this chapter, you should be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Integrate Isaac Sim with ROS/ROS2 for robot control"}),"\n",(0,t.jsx)(n.li,{children:"Use Isaac ROS packages for perception and navigation"}),"\n",(0,t.jsx)(n.li,{children:"Implement real-to-sim and sim-to-real workflows"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"content-with-code-examples",children:"Content with Code Examples"}),"\n",(0,t.jsx)(n.p,{children:"Isaac ROS provides a bridge between NVIDIA's Isaac platform and the Robot Operating System, enabling developers to leverage both ecosystems."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'\x3c!-- Example launch file for Isaac ROS bridge --\x3e\n<launch>\n  \x3c!-- Start Isaac Sim --\x3e\n  <node name="isaac_sim" pkg="isaac_sim" type="isaac_sim_node" output="screen">\n    <param name="config_file" value="$(find my_robot_isaac)/config/robot_config.yaml"/>\n  </node>\n  \n  \x3c!-- Start ROS bridge --\x3e\n  <node name="ros_bridge" pkg="omni.isaac.ros_bridge" type="ros_bridge_node" output="screen">\n    <param name="publish_frequency" value="30"/>\n  </node>\n  \n  \x3c!-- Start robot controller --\x3e\n  <node name="robot_controller" pkg="my_robot_control" type="controller_node" output="screen">\n    <param name="control_rate" value="100"/>\n  </node>\n</launch>\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Example Isaac ROS node\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Image, CameraInfo\nfrom geometry_msgs.msg import Twist\nfrom cv_bridge import CvBridge\nimport numpy as np\n\nclass IsaacROSController(Node):\n    def __init__(self):\n        super().__init__(\'isaac_ros_controller\')\n        \n        # Initialize CvBridge for image conversion\n        self.bridge = CvBridge()\n        \n        # Create subscribers for Isaac Sim sensors\n        self.image_sub = self.create_subscription(\n            Image,\n            \'/front_camera/image_raw\',\n            self.image_callback,\n            10)\n        \n        self.camera_info_sub = self.create_subscription(\n            CameraInfo,\n            \'/front_camera/camera_info\',\n            self.camera_info_callback,\n            10)\n        \n        # Create publisher for robot control\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n        \n        # Timer for control loop\n        self.timer = self.create_timer(0.1, self.control_loop)\n        \n        # Internal state\n        self.latest_image = None\n        self.camera_info = None\n        self.obstacle_detected = False\n\n    def image_callback(self, msg: Image):\n        """Process images from Isaac Sim"""\n        try:\n            # Convert ROS Image to OpenCV\n            cv_image = self.bridge.imgmsg_to_cv2(msg, desired_encoding=\'bgr8\')\n            \n            # Simple obstacle detection (in a real application, this would be more sophisticated)\n            gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)\n            height, width = gray.shape\n            \n            # Check the center region for obstacles (using intensity as a proxy)\n            center_region = gray[int(height*0.4):int(height*0.6), int(width*0.4):int(width*0.6)]\n            avg_intensity = np.mean(center_region)\n            \n            self.obstacle_detected = avg_intensity < 50  # Adjust threshold as needed\n            self.latest_image = cv_image\n            \n        except Exception as e:\n            self.get_logger().error(f\'Error processing image: {e}\')\n\n    def camera_info_callback(self, msg: CameraInfo):\n        """Store camera calibration parameters"""\n        self.camera_info = msg\n\n    def control_loop(self):\n        """Main control loop"""\n        msg = Twist()\n        \n        if self.obstacle_detected:\n            # Stop if obstacle detected\n            msg.linear.x = 0.0\n            msg.angular.z = 0.5  # Turn to avoid obstacle\n        else:\n            # Move forward otherwise\n            msg.linear.x = 0.5\n            msg.angular.z = 0.0\n        \n        self.cmd_vel_pub.publish(msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = IsaacROSController()\n    \n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,t.jsx)(n.h2,{id:"mermaid-diagrams",children:"Mermaid Diagrams"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"graph TD;\n    A[Real Robot] --\x3e B[Isaac ROS Bridge]\n    C[Isaac Sim] --\x3e B\n    B --\x3e D[ROS/ROS2 Ecosystem]\n    D --\x3e E[Navigation Stack]\n    D --\x3e F[Perception Nodes]\n    D --\x3e G[Control Nodes]\n    E --\x3e H[Path Planner]\n    F --\x3e I[Object Detector]\n    G --\x3e J[Controller]\n"})}),"\n",(0,t.jsx)(n.h2,{id:"callouts",children:"Callouts"}),"\n",(0,t.jsx)(o.A,{type:"info",children:(0,t.jsx)(n.p,{children:"Isaac ROS packages provide GPU-accelerated perception algorithms that can significantly outperform CPU-only implementations in ROS."})}),"\n",(0,t.jsx)(o.A,{type:"tip",children:(0,t.jsx)(n.p,{children:"Use Isaac Sim to develop and test ROS nodes before deploying to real hardware, reducing development time and risk."})}),"\n",(0,t.jsx)(o.A,{type:"caution",children:(0,t.jsx)(n.p,{children:"Performance characteristics in simulation may differ from real hardware. Always validate on real robots before deployment."})}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Set up Isaac Sim with ROS bridge for a robot model"}),"\n",(0,t.jsx)(n.li,{children:"Implement a simple navigation stack using Isaac ROS packages"}),"\n",(0,t.jsx)(n.li,{children:"Test robot control in simulation before real-world deployment"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Isaac ROS enables integration between Isaac platform and ROS/ROS2"}),"\n",(0,t.jsx)(n.li,{children:"GPU-accelerated perception algorithms improve performance"}),"\n",(0,t.jsx)(n.li,{children:"Simulation helps develop and test ROS nodes safely"}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(m,{...e})}):m(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>o,x:()=>s});var r=a(6540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);